<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><title>Kiyeon&#39;s Blog</title><link rel=stylesheet type=text/css href=/css/ybasic.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atelier-heath-dark.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/dos.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/lisp.min.js></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class=content><h1 class=title title="December 12, 2017 10:46:46">CRLF</h1><nav id=TableOfContents><ul><li><a href=#운영체제별-줄바꿈-문자>운영체제별 줄바꿈 문자</a></li><li><a href=#crlf-충돌>CRLF 충돌</a></li><li><a href=#crlf-수정>CRLF 수정</a><ul><li><a href=#git>GIT</a></li><li><a href=#vim>VIM</a></li><li><a href=#jetbrains-ides-sublime-text>JetBrains IDEs &amp; Sublime Text</a></li></ul></li></ul></nav><p>CRLF는 <a href=https://ko.wikipedia.org/wiki/%EC%83%88%EC%A4%84_%EB%AC%B8%EC%9E%90>새줄 문자</a>를 말한다. New Line, Line Break, Line Separators, EOL(End-Of-Line)라고도 한다.</p><p><strong>CR(Carrige Return)</strong></p><ul><li>현재 라인에서 캐리지(커서)를 제일 앞으로 이동하는 동작</li><li>아스키(13, 0x0D), \r</li></ul><p><strong>LF(Line Feed)</strong></p><ul><li>종이를 한 라인 위로 올리는 동작</li><li>아스키(10, 0x0A), \n</li></ul><h1 id=운영체제별-줄바꿈-문자>운영체제별 줄바꿈 문자</h1><p>OS별로 줄바꿈 문자가 다르다.</p><blockquote><p>역사<br>ISO와 ASA(ANSI의 전신)는 동시에 ASCII를 개발했다. 1963년부터 1968년까지 ISO 초안은 CR+LF와 LF를 새줄 문자로 정했다. ASA의 초안은 CR+LF만 지원했다. CR+LF는 텔레타이프, ASR33을 콘솔 장치로 사용한 초기 컴퓨터 시스템에서 널리 쓰였다.</p><p><strong>텔레타이프의 프린터가 다음 줄의 처음부터 인쇄하기 위해서는 두 글자를 인쇄하는 시간이 필요했다.</strong> 텔레타이프는 텍스트의 한 글자를 같은 시간 간격으로만 프린터로 전송할 수 있었다. <strong>프린터에서 좌우로 움직이는 장치가 캐리지(carriage)</strong>였는데 <strong>이것이 오른쪽 끝에서 왼쪽 끝으로 이동하는 시간이 두 글자 인쇄하는 만큼 걸렸다.</strong> 새줄 문자로 코드 하나만 쓸 경우 다른 한 글자를 인쇄할 수 없었다. 그래서 <strong>텔레타이프를 쓰던 시절에는 CR+LF 두 코드를 새줄 문자로 썼다.</strong> 캐리지 리턴이 먼저 전송되었다. 그리고 종이를 한 줄 옮기는 라인 피드가 이어서 전송되었다. 좌우 여백이 줄어들면 캐리지가 이동하는 시간이 더 필요하므로 CR이나 NUL을 더 채워 넣어야 할 때도 있었다.</p><p><strong>컴퓨터가 막 탄생하던 시절에는 디스크와 메모리가 비쌌기 때문에</strong> 1964년에 나온 운영 체제 멀틱스는 <strong>새줄 문자를 LF 하나로 통일</strong>했다. <strong>유닉스도 멀틱스의 새줄 문자 관례를 이어받았고 리눅스도 이 방식을 쓰고 있다.</strong></p><p>1981년에 등장한 MS-DOS는 CP/M의 CR+LF 방식을 따랐다. CP/M은 시리얼 라인으로 터미널을 연결했기 때문에 화면 전환 속도가 느렸다. 느린 터미널에서 줄바꿈이 있을 때 스크롤 하는 시간과 보조를 맞추기 위해 CR+LF 방식을 쓰는 것이 자연스러웠다. 윈도도 이 관례를 따르고 있다. - <a href=https://ko.wikipedia.org/wiki/%EC%83%88%EC%A4%84_%EB%AC%B8%EC%9E%90>위키피디아</a></p></blockquote><ul><li>Windows : CRLF(\r\n)</li><li>*nix and macOS : LF(\n)</li><li>Classic Mac : CR(\r)</li></ul><h1 id=crlf-충돌>CRLF 충돌</h1><p>한 시스템만을 사용한다면 문제없겠지만 타기종간에 파일을 주고받을때 문제가 발생한다.</p><ul><li>줄바꿈이 제대로 표현되지 않아 다닥다닥 붙는다</li><li>EOL에 특수문자(^M)가 표시된다</li></ul><p>가장 빈번한 케이스는 어떤 프로젝트를 공동으로 진행할때 어떤 개발자는 윈도우시스템을 사용하고 어떤 개발자는 맥이나 리눅스를 사용할때 같은 파일을 수정하면 줄바꿈문자의 충돌이 발생한다.</p><p>요즘 많은 IDE나 에디터들이 자동으로 시스템간 줄바꿈문자를 인삭하여 렌더링해주므로 그닥 신경쓰이지는 않지만 아무 작업도 안했는데 단지 줄바꿈으로 인해 코드가 변경되어 코드가 업데이트된다면 이력관리에 좋지 않을 것이다. 그러므로 CRLF든 LF든 하나로 통일하여 사용하는것이 좋다.<sup class=footnote-ref id=fnref:1><a rel=footnote href=#fn:1>1</a></sup></p><ul><li><strong>LF를 윈도우에서 봤을때 스크린샷(에디터, 헥사)</strong></li><li><strong>CRLF를 맥에서 봤을때 스크린샷(에디터, 헥사)</strong></li></ul><h1 id=crlf-수정>CRLF 수정</h1><p>CRLF를 LF로 수정하거나 LF를 CRLF로 수정하는 방법은 다양하다 그중 몇가지만 알아봤다.</p><h2 id=git>GIT</h2><p>위에서도 언급했듯 CRLF의 충돌이 가장 많이 발생하는 케이스는 버전관리일것이다. <a href=https://git-scm.com/book/ko/v1/Git%EB%A7%9E%EC%B6%A4-Git-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0#소스-포맷과-공백>GIT은 CRLF를 통일하여 사용할 수 있도록 옵션을 제공한다.</a></p><p><strong>core.eof</strong> 이 옵션은 CRLF나 LF 둘중 하나를 강제할 수 있다.</p><ul><li>native : 기본설정으로 시스템의 Line Ending처리 방법을 따른다.</li><li>crlf : CRLF를 Line Ending으로 사용</li><li>lf : LF를 line ending으로 사용</li></ul><p><strong>core.autocrlf</strong></p><ul><li>true(windows용) : commit할때 CRLF를 LF를 변환하고 checkout할때 LF를 CRLF로 변환한다.</li><li>input(*nix용) : commit할때만 CRLF를 LF로 변환한다.</li><li>false : autocrlf 미사용</li></ul><p><strong>.gitattributes</strong><br>Git은 <a href="https://www.lesstif.com/pages/viewpage.action?pageId=20776404">.gitattributes를 통해 특정 패턴의 파일들에 대해 crlf를 처리하도록 할 수 있다.</a> .gitignore와 비슷하게 저장소에 공유하면 core옵션설정을 하지 않아도 저장소 공유멤버에게 동일하게 적용되는 장점이 있다.</p><p>단, 주의할점은 공식 Git 클라이언트외에 다른 Git 클라이언트에서 위 옵션들을 체크하지 않을 수 있으므로 해당 옵션을 사용할 것이라면 현재 사용중인 클라이언트에서 지원하지는 점검이 필요하다.</p><h2 id=vim>VIM</h2><p>CR, LF, ^M - vi로 DOS&lt;-&gt;UNIX 줄바꿈 전환 vi로 DOS&lt;-&gt;UNIX 줄바꿈 전환</p><p>CR, LF 는 줄바꿈 문자.. DOS&lt;-&gt;Unix화일 주고 받을때 종종 문제가 되는데.. 모른척 종종 넘겨버렷으나 이번기회에 대충 집고 넘어가기..</p><ul><li>유닉스(Unix)/리눅스(Linux)에는, LF (헥사로는 0x0A에 해당) 문자로 줄바꿈을 하고</li><li>도스(DOS)/윈도우(Windows)에서는, CR-LF (헥사로는 0x0D 0x0A에 해당) 라는 2문자로 줄바꿈을 하고</li><li>맥(Mac)에서는, CR (헥사로는 0x0D 에 해당) 로 줄바꿈합니다. &ldquo;\n&rdquo; 로 표현합니다.</li></ul><p>줄바꿈 문자는 눈에 보이지 않기 때문에, 파일로 저장한 후, &ldquo;헥사 뷰어&rdquo;나, &ldquo;헥사 에디터&rdquo;로 보아야 알 수 있다. UltraEdit Edit-&gt;Hex Functions을 사용하거나.. cmd&gt; hexdump.pl FileName.txt</p><p>유닉스에서 DOS화일을 바꾸는 방법(출처:<a href=http://yoonow.tistory.com/56>http://yoonow.tistory.com/56</a>) 1. vi(m)이 열린 상태 1.1 문자 치환 명령 이용</p><p>다음과 같이 문자 치환 명령으로 이 문자를 없애도록 합니다. :1,$s/^M//g</p><p>물론 이것의 입력은 다음과 같이 하도록 합니다. :1,$s/[Control]+v+m을 누른다.//g</p><p>1.2 파일포맷 변경</p><p>vim 5.0 이상에서는 다음과 같이 명령을 내리도록 합니다 :set fileformat=unix</p><p>혹은 :set ff=unix</p><p>그리고, 저장하고 종료합니다. :wq</p><p>이와 반대로 끝에 ^M 을 붙이려면(과연 누가..) 다음과 같이 합니다. :set fileformat=dos</p><p>이전버전에서는 다음과 같이 합니다. :set textmode</p><ol><li>프롬프트 상에서 2.1 dos2unix 이용</li></ol><p>dos2unix와 unix2dos를 이용하여 변환할 수 있습니다.</p><p>다음과 같이 하면 ^M 문자가 없어집니다. $ dos2unix fileName.txt</p><p>^M is ascii 15 so : $ sed &rsquo;s/&rsquo;<code>echo &quot;\015&quot;</code>&rsquo;//g&rsquo; file &gt; filenew</p><p>tr -d &ldquo;\015\032&rdquo; &lt; dosfile &gt; unixfile 015 is CR 032 is Ctrl-Z</p><p>그리고 다음과 같이 하면 ^M 문자가 생기죠. $ unix2dos FileeName.txt</p><p>2.2 cat과 tr을 이용한 방법</p><p>다음과 같이 하면 해당 파일의 ^M 문자가 없어집니다. $ cat dos-file | tr -d ^M &gt; unix-file</p><p>2.3 perl 스크립트</p><p>다음과 같이 하면 여러파일을 한번에 바꾸게 됩니다. # perl -i -pe &rsquo;s/\015//g&rsquo; *.html</p><p>*** How to insert CR, LF in SQR *** chr(13) is the indicator for Carriage Return (CR). chr(10) is the character for Line Feed (LF). Here is example code that uses both:</p><p>let $cr = chr(13) let $lf = chr(10) let $crlf = $cr || $lf</p><h2 id=jetbrains-ides-sublime-text>JetBrains IDEs &amp; Sublime Text</h2><p>화면하단 상태바에 EOL을 설정할 수 있는 메뉴가 있다. CRLF를 DOS 또는 Windows모드, LF를 UNIX 모드로 표시한다.</p><p><strong>스크린샷</strong></p><div class=footnotes><hr><ol><li id=fn:1>오픈소스진영에서는 많은 프로젝트에서 LF를 사용하는 경우가 많다. <a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li></ol></div><div id=disqus_thread></div><script type=text/javascript>
        (function() {
            
            
            if (window.location.hostname == "localhost")
                return;

            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            var disqus_shortname = 'kiyeon';
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href="http://disqus.com/" class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><footer>Kiyeon&#39;s Blog</footer><script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-79101-12', 'auto');
    ga('send', 'pageview');

</script></body></html>